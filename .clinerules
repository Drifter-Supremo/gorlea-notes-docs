# ðŸ§  Cline Rules: Gorlea Notes

## Project Patterns

### File Organization
- Memory bank files use emoji prefixes for quick recognition (`/memory-bank/`)
- All documentation in Markdown format
- Frontend: `/client-vite/src/` for source files (Vite project)
- Backend: `/server/` for Express.js server code
- Utilities: `/server/utils/` for shared backend code

### Naming Conventions
- Files: kebab-case.js
- Components: PascalCase
- Functions: camelCase
- CSS Classes: kebab-case
- Constants: UPPER_SNAKE_CASE

### Code Style
- Prefer const over let
- Use template literals for string interpolation
- Async/await over .then() chains
- Early returns for cleaner logic
- JSDoc comments for functions

### Git Workflow
- Feature branches from main
- Branch naming: feature/description
- Commit messages follow conventional commits
- Squash merges into main

## User Preferences

### Documentation
- Markdown for all documentation
- Mermaid diagrams for visualizations
- Emoji usage for visual categorization
- Detailed comments for complex logic

### Project Structure
- Modular architecture
- Clear separation of concerns
- Minimal dependencies
- Progressive enhancement

### Development Focus
- User experience first
- Performance critical
- Security by design
- Accessibility required

## Critical Paths

### Note Creation Flow
1. User enters note in chat
2. AI processes and cleans note
3. System suggests save locations (existing Firestore doc or new)
4. Note saved/appended to Firestore document (with timestamp separator)
5. Confirmation shown to user

### Authentication Flow
1. User clicks login
2. Google OAuth popup
3. Token validation
4. Session creation
5. Redirect to chat

## Known Challenges

### API Integration
- Firestore write limits/costs (potential challenge)
- Token refresh handling (Google OAuth)
- Error recovery (Network, API)
- Timeout management (AI, Firestore)

### AI Processing
- Response time optimization
- Error handling
- Fallback mechanisms
- Context preservation

## Tool Usage Patterns

### File Editing
- Always use replace_in_file over write_to_file when possible
- SEARCH blocks must match file content exactly:
  - Include surrounding context (comments, blank lines)
  - Match indentation precisely
  - Use multiple lines for uniqueness
  - Keep changes focused and minimal
- Verify file content before editing:
  - Read file first
  - Copy exact content for SEARCH blocks
  - Check final_file_content for auto-formatting
- Handle errors gracefully:
  - If replace_in_file fails twice, consider alternatives
  - Never assume file content without verification
  - Document any formatting changes

### Development
- VSCode as primary editor
- Chrome DevTools for debugging
- Firebase CLI for deployment
- Git for version control

### Testing
- Manual testing for UI
- Jest for unit tests
- Cypress for E2E (future)
- Postman for API testing

### Notion MCP Tools
- Always use specific Page/Database/User IDs found in `memory-bank/notionContext.md`.
- Verify the "Cline" integration has permissions for the target page/database before use.
- Use `notion_create_database_item` for new tasks, `notion_update_page_properties` for updates, `notion_create_comment` for adding comments.
- Assign users via the User ID: `1d0d872b-594c-81ae-9b29-00022622ce1f` (Drifter Supremo).

## Project Intelligence

### Performance Considerations
- Minimize API calls
- Optimize AI requests
- Efficient doc operations
- Smart caching strategy

### Security Measures
- Strict CSP headers
- Input sanitization
- Token validation
- Error masking

### UX Patterns
- Minimal cognitive load
- Clear feedback
- Graceful degradation
- Progressive disclosure

## Evolution Notes

### Initial Decisions
- Vanilla JS for MVP (using Vite)
- Express.js backend
- Google Gemini primary AI
- Firestore for storage
- Mobile-first design

### Future Considerations
- React migration path
- Search implementation
- Voice input addition
- Smart categorization

## Learning Points

### Technical
- Firestore data modeling and querying
- AI processing strategies (Gemini)
- Google OAuth implementation
- Express.js middleware and routing
- Vite build/proxy configuration
- Tiptap editor integration
- Frontend state management (localStorage for chat)

### Process
- Documentation first
- Iterative development
- Regular testing
- Continuous learning

---

This file captures key project patterns and intelligence. Update as new patterns emerge or existing ones evolve.
